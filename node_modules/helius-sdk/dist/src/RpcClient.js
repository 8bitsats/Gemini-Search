"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = void 0;
const web3_js_1 = require("@solana/web3.js");
const axios_1 = __importDefault(require("axios"));
/**
 * The beefed up RPC client from Helius SDK
 */
class RpcClient {
    constructor(connection, id) {
        this.connection = connection;
        this.id = id;
    }
    /**
     * Request an allocation of lamports to the specified address
     * @returns {Promise<SendAndConfirmTransactionResponse>}
     */
    airdrop(publicKey, lamports, commitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.connection.requestAirdrop(publicKey, lamports);
            const blockhashWithExpiryBlockHeight = yield this.getLatestBlockhash();
            const confirmResponse = yield this.connection.confirmTransaction(Object.assign({ signature }, blockhashWithExpiryBlockHeight), commitment);
            return Object.assign({ signature, confirmResponse }, blockhashWithExpiryBlockHeight);
        });
    }
    /**
     * Fetch the latest blockhash from the cluster
     * @returns {Promise<BlockhashWithExpiryBlockHeight>}
     */
    getLatestBlockhash(commitmentOrConfig = "finalized") {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.getLatestBlockhash(commitmentOrConfig);
        });
    }
    /**
     * Returns the current transactions per second (TPS) rate â€” including voting transactions.
     *
     * @returns {Promise<number>} A promise that resolves to the current TPS rate.
     * @throws {Error} If there was an error calling the `getRecentPerformanceSamples` method.
     */
    getCurrentTPS() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const samples = yield this.connection.getRecentPerformanceSamples(1);
                return ((_a = samples[0]) === null || _a === void 0 ? void 0 : _a.numTransactions) / ((_b = samples[0]) === null || _b === void 0 ? void 0 : _b.samplePeriodSecs);
            }
            catch (e) {
                throw new Error(`error calling getCurrentTPS: ${e}`);
            }
        });
    }
    /**
     * Returns all the stake accounts for a given public key
     *
     * @returns {Promise<number>} A promise that resolves to the current TPS rate.
     * @throws {Error} If there was an error calling the `getStakeAccounts` method.
     */
    getStakeAccounts(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.connection.getParsedProgramAccounts(new web3_js_1.PublicKey("Stake11111111111111111111111111111111111111"), {
                    filters: [
                        {
                            dataSize: 200,
                        },
                        {
                            memcmp: {
                                offset: 44,
                                bytes: wallet,
                            },
                        },
                    ],
                });
            }
            catch (e) {
                throw new Error(`error calling getStakeAccounts: ${e}`);
            }
        });
    }
    /**
     * Returns all the token accounts for a given mint address (ONLY FOR SPL TOKENS)
     *
     * @returns {Promise<{pubkey: PublicKey; account: AccountInfo<ParsedAccountData | Buffer}[]>} A promise that resolves to an array of accountInfo
     * @throws {Error} If there was an error calling the `getTokenHolders` method.
     */
    getTokenHolders(mintAddress) {
        try {
            return this.connection.getParsedProgramAccounts(new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), {
                filters: [
                    {
                        dataSize: 165,
                    },
                    {
                        memcmp: {
                            offset: 0,
                            bytes: mintAddress,
                        },
                    },
                ],
            });
        }
        catch (e) {
            throw new Error(`error calling getTokenHolders: ${e}`);
        }
    }
    /**
     * Get a single asset by ID.
     * @param {DAS.GetAssetRequest | string} id - Asset ID
     * @returns {Promise<DAS.GetAssetResponse>}
     * @throws {Error}
     */
    getAsset(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAsset",
                    params,
                }, {
                    headers: {
                        "Content-Type": "application/json",
                    },
                });
                const result = response.data.result;
                return result;
            }
            catch (error) {
                throw new Error(`Error in getAsset: ${error}`);
            }
        });
    }
    /**
     * Get multiple assets.
     * @returns {Promise<DAS.GetAssetResponse[]>}
     * @throws {Error}
     */
    getAssetBatch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAssetBatch",
                    params, // <-- Here we directly pass the params
                });
                return response.data.result;
            }
            catch (error) {
                throw new Error(`Error in getAssetBatch: ${error}`);
            }
        });
    }
    /**
     * Get Asset proof.
     * @returns {Promise<DAS.GetAssetProofResponse>}
     * @throws {Error}
     */
    getAssetProof(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAssetProof",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in getAssetProof: ${error}`);
            }
        });
    }
    /**
     * Get Assets By group.
     * @returns {Promise<DAS.GetAssetResponseList>}
     * @throws { Error }
     */
    getAssetsByGroup(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAssetsByGroup",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in getAssetsByGroup: ${error}`);
            }
        });
    }
    /**
     * Get all assets (compressed and regular) for a public key.
     * @returns {Promise<DAS.GetAssetResponseList>}
     * @throws {Error}
     */
    getAssetsByOwner(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAssetsByOwner",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in getAssetsByOwner: ${error}`);
            }
        });
    }
    /**
     * Request assets for a given creator.
     * @returns {Promise<DAS.GetAssetResponseList>}
     * @throws {Error}
     */
    getAssetsByCreator(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAssetsByCreator",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in getAssetsByCreator: ${error}`);
            }
        });
    }
    /**
     * Get assets by authority.
     * @returns {Promise<DAS.GetAssetResponseList>}
     * @throws {Error}
     */
    getAssetsByAuthority(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getAssetsByAuthority",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in getAssetsByAuthority: ${error}`);
            }
        });
    }
    /**
     * Search Assets
     * @returns {Promise<DAS.GetAssetResponseList>}
     * @throws {Error}
     */
    searchAssets(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "searchAssets",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in searchAssets: ${error}`);
            }
        });
    }
    /**
     * Get transaction history for the asset.
     * @returns {Promise<GetSignatureForAssetResponse>}
     * @throws {Error}
     */
    getSignaturesForAsset(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.rpcEndpoint}`;
                const response = yield axios_1.default.post(url, {
                    jsonrpc: "2.0",
                    id: this.id,
                    method: "getSignaturesForAsset",
                    params: params,
                });
                const data = response.data;
                return data.result;
            }
            catch (error) {
                throw new Error(`Error in getSignaturesForAsset: ${error}`);
            }
        });
    }
}
exports.RpcClient = RpcClient;
